import 'dart:convert';

import 'package:coinbase_cloud_advanced_trade_client/src/models/cancel_orders.dart';
import 'package:coinbase_cloud_advanced_trade_client/src/models/credential.dart';
import 'package:coinbase_cloud_advanced_trade_client/src/models/error.dart';
import 'package:coinbase_cloud_advanced_trade_client/src/models/order.dart';
import 'package:coinbase_cloud_advanced_trade_client/src/models/order_configuration.dart';
import 'package:coinbase_cloud_advanced_trade_client/src/services/network.dart';
import 'package:http/http.dart' as http;
import 'package:http/http.dart';

/// Gets a list of historical orders for the current user.
///
/// GET /v3/brokerage/orders/historical/batch
/// https://docs.cdp.coinbase.com/api-reference/advanced-trade-api/rest-api/orders/list-orders
///
/// This function makes a GET request to the /orders/historical/batch endpoint
/// of the Coinbase Advanced Trade API. It supports pagination using a cursor.
///
/// [limit] - A limit on the number of orders to be returned.
/// [cursor] - A cursor for pagination.
/// [credential] - The user's API credentials.
/// [isSandbox] - Whether to use the sandbox environment.
///
/// Returns a list of [Order] objects.
Future<List<Order>> getOrders(
    {int? limit = 1000,
    String? cursor,
    http.Client? client,
    required Credential credential,
    bool isSandbox = false}) async {
  List<Order> orders = [];
  Map<String, dynamic>? queryParameters = {'limit': '$limit'};
  (cursor != null) ? queryParameters.addAll({'cursor': cursor}) : null;

  http.Response response = await getAuthorized('/orders/historical/batch',
      queryParameters: queryParameters,
      client: client,
      credential: credential,
      isSandbox: isSandbox);

  if (response.statusCode == 200) {
    String data = response.body;
    var jsonResponse = jsonDecode(data);
    var jsonAccounts = jsonResponse['orders'];
    String? jsonCursor = jsonResponse['cursor'];

    for (var jsonObject in jsonAccounts) {
      orders.add(Order.fromCBJson(jsonObject));
    }
    // Recursive Break
    if (jsonCursor != null && jsonCursor != '') {
      // Recursive Call
      List<Order> paginatedAccounts = await getOrders(
          limit: limit,
          cursor: jsonCursor,
          credential: credential,
          isSandbox: isSandbox);
      orders.addAll(paginatedAccounts);
    }
  } else {
    throw CoinbaseException(
        'Failed to get orders', response.statusCode, response.body);
  }

  return orders;
}

/// Gets a single historical order for the current user by order ID.
///
/// GET /v3/brokerage/orders/historical/{order_id}
/// https://docs.cdp.coinbase.com/api-reference/advanced-trade-api/rest-api/orders/get-order
///
/// This function makes a GET request to the /orders/historical/{order_id}
/// endpoint of the Coinbase Advanced Trade API.
///
/// [orderId] - The ID of the order to be returned.
/// [credential] - The user's API credentials.
/// [isSandbox] - Whether to use the sandbox environment.
///
/// Returns an [Order] object, or null if no order is found for the given
/// order ID.
Future<Order?> getOrder(
    {required String orderId,
    http.Client? client,
    required Credential credential,
    bool isSandbox = false}) async {
  Order? order;

  http.Response response = await getAuthorized('/orders/historical/$orderId',
      client: client, credential: credential, isSandbox: isSandbox);

  if (response.statusCode == 200) {
    String data = response.body;
    var jsonResponse = jsonDecode(data);
    var jsonOrder = jsonResponse['order'];
    order = Order.fromCBJson(jsonOrder);
  } else {
    throw CoinbaseException(
        'Failed to get order', response.statusCode, response.body);
  }

  return order;
}

/// Creates a market order. IOC: Immediate or Cancel.
/// Buy or sell a specified quantity of an Asset at the current best available market price.
///
/// POST /v3/brokerage/orders
/// https://docs.cdp.coinbase.com/api-reference/advanced-trade-api/rest-api/orders/create-order
///
/// [clientOrderId] - A unique ID for the order, generated by the client.
/// [productId] - The ID of the product to trade.
/// [side] - The side of the order (BUY or SELL).
/// [quoteSize] - The amount of quote currency to spend on a BUY order, or the
/// amount of base currency to sell on a SELL order.
/// [baseSize] - The amount of base currency to buy on a BUY order, or the
/// amount of quote currency to receive on a SELL order.
/// [credential] - The user's API credentials.
/// [isSandbox] - Whether to use the sandbox environment.
///
/// Returns a map containing the result of the order creation, or null if the
/// request fails.
Future<Map<String, dynamic>?> createMarketOrder(
    {required String clientOrderId,
    required String productId,
    required String side,
    String? quoteSize,
    String? baseSize,
    required Credential credential,
    bool isSandbox = false,
    Client? client}) async {
  if (quoteSize == null && baseSize == null) {
    throw ArgumentError('Either quoteSize or baseSize must be provided.');
  }
  if (quoteSize != null && baseSize != null) {
    throw ArgumentError('Only one of quoteSize or baseSize can be provided.');
  }

  // Market IOC: Buy or sell a specified quantity of an Asset at the current best available market price.
  Map<String, dynamic>? marketMarketIOC = {};

  (quoteSize != null)
      ? marketMarketIOC.addAll({'quote_size': quoteSize})
      : null;
  (baseSize != null) ? marketMarketIOC.addAll({'base_size': baseSize}) : null;

  final orderConfiguration = {'market_market_ioc': marketMarketIOC};

  return _createOrder(
      clientOrderId: clientOrderId,
      productId: productId,
      side: side,
      orderConfiguration: orderConfiguration,
      credential: credential,
      isSandbox: isSandbox,
      client: client);
}

/// Creates a limit order. GTC: Good Till Cancelled.
/// Buy or sell a specified quantity of an Asset at a specified price.
/// If posted, the Order will remain on the Order Book until canceled.
///
/// POST /v3/brokerage/orders
/// https://docs.cdp.coinbase.com/api-reference/advanced-trade-api/rest-api/orders/create-order
///
/// [clientOrderId] - A unique ID for the order, generated by the client.
/// [productId] - The ID of the product to trade.
/// [side] - The side of the order (BUY or SELL).
/// [baseSize] - The amount of base currency to buy or sell.
/// [limitPrice] - The price at which to buy or sell the base currency.
/// [postOnly] - Whether the order should be a post-only order.
/// [credential] - The user's API credentials.
/// [isSandbox] - Whether to use the sandbox environment.
///
/// Returns a map containing the result of the order creation, or null if the
/// request fails.
Future<Map<String, dynamic>?> createLimitOrder(
    {required String clientOrderId,
    required String productId,
    required String side,
    required String baseSize,
    required String limitPrice,
    bool postOnly = false,
    required Credential credential,
    bool isSandbox = false,
    Client? client}) async {
  final orderConfiguration = {
    'limit_limit_gtc': {
      'base_size': baseSize,
      'limit_price': limitPrice,
      'post_only': postOnly,
    }
  };

  return _createOrder(
      clientOrderId: clientOrderId,
      productId: productId,
      side: side,
      orderConfiguration: orderConfiguration,
      credential: credential,
      isSandbox: isSandbox,
      client: client);
}

/// Creates a stop limit order. GTC: Good Till Cancelled.
/// An order that triggers a limit order when the last trade price hits a specified stop price.
///
/// POST /v3/brokerage/orders
/// https://docs.cdp.coinbase.com/api-reference/advanced-trade-api/rest-api/orders/create-order
///
/// [clientOrderId] - A unique ID for the order, generated by the client.
/// [productId] - The ID of the product to trade.
/// [side] - The side of the order (BUY or SELL).
/// [baseSize] - The amount of base currency to buy or sell.
/// [limitPrice] - The price at which to buy or sell the base currency.
/// [stopPrice] - The price at which the order should be triggered.
/// [stopDirection] - The direction of the stop price (ABOVE or BELOW).
/// [credential] - The user's API credentials.
/// [isSandbox] - Whether to use the sandbox environment.
///
/// Returns a map containing the result of the order creation, or null if the
/// request fails.
Future<Map<String, dynamic>?> createStopLimitOrderGTC(
    {required String clientOrderId,
    required String productId,
    required String side,
    required String baseSize,
    required String limitPrice,
    required String stopPrice,
    required StopDirection stopDirection,
    required Credential credential,
    bool isSandbox = false,
    Client? client}) async {
  final orderConfiguration = {
    'stop_limit_stop_limit_gtc': {
      'base_size': baseSize,
      'limit_price': limitPrice,
      'stop_price': stopPrice,
      'stop_direction': stopDirection.toCB(),
    }
  };

  return _createOrder(
      clientOrderId: clientOrderId,
      productId: productId,
      side: side,
      orderConfiguration: orderConfiguration,
      credential: credential,
      isSandbox: isSandbox,
      client: client);
}

/// Creates a stop limit order. GTD: Good Till Date.
/// An order that triggers a limit order when the last trade price hits a specified stop price.
/// The order will be cancelled if it is not filled by the specified end time.
///
/// POST /v3/brokerage/orders
/// https://docs.cdp.coinbase.com/api-reference/advanced-trade-api/rest-api/orders/create-order
///
/// [clientOrderId] - A unique ID for the order, generated by the client.
/// [productId] - The ID of the product to trade.
/// [side] - The side of the order (BUY or SELL).
/// [baseSize] - The amount of base currency to buy or sell.
/// [limitPrice] - The price at which to buy or sell the base currency.
/// [stopPrice] - The price at which the order should be triggered.
/// [stopDirection] - The direction of the stop price (ABOVE or BELOW).
/// [endTime] - The time at which the order should be cancelled if it is not filled.
/// [credential] - The user's API credentials.
/// [isSandbox] - Whether to use the sandbox environment.
///
/// Returns a map containing the result of the order creation, or null if the
/// request fails.
Future<Map<String, dynamic>?> createStopLimitOrderGTD(
    {required String clientOrderId,
    required String productId,
    required String side,
    required String baseSize,
    required String limitPrice,
    required String stopPrice,
    required StopDirection stopDirection,
    required DateTime endTime,
    required Credential credential,
    bool isSandbox = false,
    Client? client}) async {
  final orderConfiguration = {
    'stop_limit_stop_limit_gtd': {
      'base_size': baseSize,
      'limit_price': limitPrice,
      'stop_price': stopPrice,
      'stop_direction': stopDirection.toCB(),
      'end_time':
          '${endTime.toUtc().toIso8601String().split('.').first}.${endTime.millisecond.toString().padLeft(3, '0')}Z',
    }
  };

  return _createOrder(
      clientOrderId: clientOrderId,
      productId: productId,
      side: side,
      orderConfiguration: orderConfiguration,
      credential: credential,
      isSandbox: isSandbox,
      client: client);
}

Future<Map<String, dynamic>?> _createOrder(
    {required String clientOrderId,
    required String productId,
    required String side,
    required Map<String, dynamic> orderConfiguration,
    required Credential credential,
    bool isSandbox = false,
    Client? client}) async {
  Map<String, dynamic>? result;

  final body = {
    'client_order_id': clientOrderId,
    'product_id': productId,
    'side': side,
    'order_configuration': orderConfiguration,
  };

  http.Response response = await postAuthorized('/orders',
      body: jsonEncode(body),
      credential: credential,
      isSandbox: isSandbox,
      client: client);

  if (response.statusCode == 200) {
    String data = response.body;
    var jsonResponse = jsonDecode(data);
    result = jsonResponse;
  } else {
    throw CoinbaseException(
        'Failed to create order', response.statusCode, response.body);
  }

  return result;
}

/// Cancels a list of orders.
///
/// POST /v3/brokerage/orders/batch_cancel
/// https://docs.cdp.coinbase.com/api-reference/advanced-trade-api/rest-api/orders/cancel-order
///
/// [orderIds] - A list of order IDs to cancel.
/// [credential] - The user's API credentials.
/// [isSandbox] - Whether to use the sandbox environment.
///
/// Returns a [CanceledOrders] object.
Future<CanceledOrders?> cancelOrders(
    {required List<String> orderIds,
    required Credential credential,
    bool isSandbox = false,
    Client? client}) async {
  CanceledOrders? result;

  final body = {
    'order_ids': orderIds,
  };

  http.Response response = await postAuthorized('/orders/batch_cancel',
      body: jsonEncode(body),
      credential: credential,
      isSandbox: isSandbox,
      client: client);

  if (response.statusCode == 200) {
    String data = response.body;
    var jsonResponse = jsonDecode(data);
    result = CanceledOrders.fromCBJson(jsonResponse);
  } else {
    throw CoinbaseException(
        'Failed to cancel orders', response.statusCode, response.body);
  }

  return result;
}

/// Closes a position for a given product ID.
///
/// POST /v3/brokerage/orders/close_position
/// https://docs.cdp.coinbase.com/api-reference/advanced-trade-api/rest-api/orders/close-position
///
/// [productId] - The ID of the product to close the position for.
/// [credential] - The user's API credentials.
/// [isSandbox] - Whether to use the sandbox environment.
///
/// Returns a map containing the result of the close position request.
Future<Map<String, dynamic>?> closePosition(
    {required String productId,
    required Credential credential,
    bool isSandbox = false,
    Client? client}) async {
  Map<String, dynamic>? result;

  final body = {
    'product_id': productId,
  };

  http.Response response = await postAuthorized('/orders/close_position',
      body: jsonEncode(body),
      credential: credential,
      isSandbox: isSandbox,
      client: client);

  if (response.statusCode == 200) {
    var url = response.request?.url.toString();
    print('Request to URL $url Success: Response code ${response.statusCode}');
    print('Success Response Message: ${response.body}');
    String data = response.body;
    var jsonResponse = jsonDecode(data);
    result = jsonResponse;
  } else {
    throw CoinbaseException(
        'Failed to close position', response.statusCode, response.body);
  }

  return result;
}
